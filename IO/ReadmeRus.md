# IO Устройства

Данный раздел содержит реализацию логики различных устройств ввода/вывода для NES/Famicom/Dendy, портов расширения и сопроводительных чипов.

TBD: порты расширения пока не реализованы и не рассматриваются.

## Введение

Как может показаться - что может быть сложного в обычном контроллере? Однако...

- Соединение контроллеров различается у NES/Famicom/Dendy. NES/Dendy использует соединение через порты. В Famicom контроллеры неразъёмно соединены с основным юнитом.
- На втором контроллере Famicom пристутствует микрофон (да, такой вот wtf из 90-х)
- На Dendy контроллерах присутствуют Turbo-кнопки

И как вот это всё генерализовать красиво? :-)

## Архитектура IO подсистемы

- Реализация логики устройств находится в нативном коде
- Каждое устройство ввода снабжается уникальным идентификатором, полностью определяющим его модель и реализацию (DeviceID); список всех идентификаторов в io.h
- Описание Motherboard в BoardDescription.json содержит список портов (IOPort). Каждый порт содержит список ID устройств, которые можно к нему подключить (Attach / Detach)
- IO подсистема содержит фабрику для создания устройств по его DeviceID. Созданное устройство определяется описателем, целым числом > 0 (Handle)
- Каждое устройство предоставляет список своих контролов ввода/вывода (IOState). Каждый IOState определяется целым числом > 0
- Устройство содержит метод SetState, которым может пользоваться потребитель, для установки состояний IOState контролов

## Настройка IO устройств

Со стороны эмулятора настройка подразумевает просто привязку IOState к какому-то API для работы с устройствами ввода на стороне ПК. 
После чего ассоциативная связь используется для установки SetState подключенному устройству.

Эмулятор содержит пул зарегистрированных устройств с указанием DeviceID (устройства добавляет и удаляет пользователь).

Далее каждое устройство можно настроить (грубо говоря сделать привязку IOState к DirectInput/XInput или ещё какому-то API).

После настройки устройство можно подключить или отключить к указанной модели материнской платы (Attach / Detach). После запуска эмуляции для IO подсистемы будут созданы инстанции подключенных устройств, подключены к портам и далее эмулятор может вызывать со своей стороны SetState, чтобы нативная реализация преобразовывала IOState в конкретные сигналы для портов ввода/вывода.

Опять же описание весьма абстрактное, по ходу работ оно кристаллизуется в конкретные классы/методы.

## Famicom Controller (Port1)

![famicom_controller1](/UserManual/imgstore/famicom_controller1.png)

DeviceID: 0x00000001

|IOState|Actuator|Values|
|---|---|---|
|1|Up|0/1|
|2|Down|0/1|
|3|Left|0/1|
|4|Right|0/1|
|5|Select|0/1|
|6|Start|0/1|
|7|B|0/1|
|8|A|0/1|

Контроллеры Famicom хотя внешне и не съёмные, но внутри корпуса их таки можно отсоединить, поэтому для унификации кода будем считать их съёмными.

## Famicom Controller (Port2)

![famicom_controller2](/UserManual/imgstore/famicom_controller2.png)

DeviceID: 0x00000002

|IOState|Actuator|Values|
|---|---|---|
|1|Up|0/1|
|2|Down|0/1|
|3|Left|0/1|
|4|Right|0/1|
|5|Volume|0...255|
|6|MicLevel|0...255|
|7|B|0/1|
|8|A|0/1|

Значения громкости и уровня микрофона пока в диапазоне UInt8, посмотрим насколько эта модель хорошая в процессе.

## NES Controller (Port1/2)

![nes_controller](/UserManual/imgstore/nes_controller.png)

DeviceID: 0x00000003

|IOState|Actuator|Values|
|---|---|---|
|1|Up|0/1|
|2|Down|0/1|
|3|Left|0/1|
|4|Right|0/1|
|5|Select|0/1|
|6|Start|0/1|
|7|B|0/1|
|8|A|0/1|

## Dendy Controller (Port1/2)

![dendy_controller](/UserManual/imgstore/dendy_controller.png)

DeviceID: 0x00000004

|IOState|Actuator|Values|
|---|---|---|
|1|Up|0/1|
|2|Down|0/1|
|3|Left|0/1|
|4|Right|0/1|
|5|Select|0/1|
|6|Start|0/1|
|7|TurboB|0/1|
|8|TurboA|0/1|
|9|B|0/1|
|10|A|0/1|
