# IO Устройства

Данный раздел содержит реализацию логики различных устройств ввода/вывода для NES/Famicom/Dendy, портов расширения и сопроводительных чипов.

TBD: порты расширения пока не реализованы и не рассматриваются.

## Введение

Как может показаться - что может быть сложного в обычном контроллере? Однако...

- Соединение контроллеров различается у NES/Famicom/Dendy. NES/Dendy использует соединение через порты. В Famicom контроллеры неразъёмно соединены с основным юнитом.
- На втором контроллере Famicom пристутствует микрофон (да, такой вот wtf из 90-х)
- На Dendy контроллерах присутствуют Turbo-кнопки

И как вот это всё генерализовать красиво? :-)

## Архитектура IO подсистемы

- Реализация логики устройств находится в нативном коде
- Каждое устройство ввода снабжается уникальным идентификатором, полностью определяющим его модель и реализацию (DeviceID); список всех идентификаторов в io.h
- Описание Motherboard в BoardDescription.json содержит список портов (IOPort). Каждый порт содержит список ID устройств, которые можно к нему подключить (Attach / Detach)
- IO подсистема содержит фабрику для создания устройств по его DeviceID. Созданное устройство определяется описателем, целым числом > 0 (Handle)
- Каждое устройство предоставляет список своих контролов ввода/вывода (IOState). Каждый IOState определяется целым числом > 0
- Устройство содержит метод SetState, которым может пользоваться потребитель, для установки состояний IOState контролов

## Настройка IO устройств

Со стороны эмулятора настройка подразумевает просто привязку IOState к какому-то API для работы с устройствами ввода на стороне ПК. 
После чего ассоциативная связь используется для установки SetState подключенному устройству.

Эмулятор содержит пул зарегистрированных устройств с указанием DeviceID (устройства добавляет и удаляет пользователь).

Далее каждое устройство можно настроить (грубо говоря сделать привязку IOState к DirectInput/XInput или ещё какому-то API).

После настройки устройство можно подключить или отключить к указанной модели материнской платы (Attach / Detach). После запуска эмуляции для IO подсистемы будут созданы инстанции подключенных устройств, подключены к портам и далее эмулятор может вызывать со своей стороны SetState, чтобы нативная реализация преобразовывала IOState в конкретные сигналы для портов ввода/вывода.

Опять же описание весьма абстрактное, по ходу работ оно кристаллизуется в конкретные классы/методы.
